/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * WritableManifest(metadata: dbt.contracts.graph.manifest.ManifestMetadata, nodes: Mapping[str, Union[dbt.contracts.graph.nodes.AnalysisNode, dbt.contracts.graph.nodes.SingularTestNode, dbt.contracts.graph.nodes.HookNode, dbt.contracts.graph.nodes.ModelNode, dbt.contracts.graph.nodes.RPCNode, dbt.contracts.graph.nodes.SqlNode, dbt.contracts.graph.nodes.GenericTestNode, dbt.contracts.graph.nodes.SnapshotNode, dbt.contracts.graph.nodes.SeedNode]], sources: Mapping[str, dbt.contracts.graph.nodes.SourceDefinition], macros: Mapping[str, dbt.contracts.graph.nodes.Macro], docs: Mapping[str, dbt.contracts.graph.nodes.Documentation], exposures: Mapping[str, dbt.contracts.graph.nodes.Exposure], metrics: Mapping[str, dbt.contracts.graph.nodes.Metric], groups: Mapping[str, dbt.contracts.graph.nodes.Group], selectors: Mapping[str, Any], disabled: Union[Mapping[str, List[Union[dbt.contracts.graph.nodes.AnalysisNode, dbt.contracts.graph.nodes.SingularTestNode, dbt.contracts.graph.nodes.HookNode, dbt.contracts.graph.nodes.ModelNode, dbt.contracts.graph.nodes.RPCNode, dbt.contracts.graph.nodes.SqlNode, dbt.contracts.graph.nodes.GenericTestNode, dbt.contracts.graph.nodes.SnapshotNode, dbt.contracts.graph.nodes.SeedNode, dbt.contracts.graph.nodes.SourceDefinition, dbt.contracts.graph.nodes.Exposure, dbt.contracts.graph.nodes.Metric, dbt.contracts.graph.nodes.SemanticModel]]], NoneType], parent_map: Union[Dict[str, List[str]], NoneType], child_map: Union[Dict[str, List[str]], NoneType], group_map: Union[Dict[str, List[str]], NoneType], semantic_models: Mapping[str, dbt.contracts.graph.nodes.SemanticModel])
 */
export interface DbtManifestSchema {
  /**
   * Metadata about the manifest
   */
  metadata: {
    dbt_schema_version?: string;
    dbt_version?: string;
    generated_at?: string;
    invocation_id?: string | null;
    env?: {
      [k: string]: string;
    };
    /**
     * Name of the root project
     */
    project_name?: string | null;
    /**
     * A unique identifier for the project, hashed from the project name
     */
    project_id?: string | null;
    /**
     * A unique identifier for the user
     */
    user_id?: string | null;
    /**
     * Whether dbt is configured to send anonymous usage statistics
     */
    send_anonymous_usage_stats?: boolean | null;
    /**
     * The type name of the adapter
     */
    adapter_type?: string | null;
  };
  /**
   * The nodes defined in the dbt project and its dependencies
   */
  nodes: {
    [k: string]:
      | AnalysisNode
      | SingularTestNode
      | HookNode
      | ModelNode
      | RPCNode
      | SqlNode
      | GenericTestNode
      | SnapshotNode
      | SeedNode;
  };
  /**
   * The sources defined in the dbt project and its dependencies
   */
  sources: {
    [k: string]: SourceDefinition;
  };
  /**
   * The macros defined in the dbt project and its dependencies
   */
  macros: {
    [k: string]: Macro;
  };
  /**
   * The docs defined in the dbt project and its dependencies
   */
  docs: {
    [k: string]: Documentation;
  };
  /**
   * The exposures defined in the dbt project and its dependencies
   */
  exposures: {
    [k: string]: Exposure;
  };
  /**
   * The metrics defined in the dbt project and its dependencies
   */
  metrics: {
    [k: string]: Metric;
  };
  /**
   * The groups defined in the dbt project
   */
  groups: {
    [k: string]: Group;
  };
  /**
   * The selectors defined in selectors.yml
   */
  selectors: {
    [k: string]: unknown;
  };
  /**
   * A mapping of the disabled nodes in the target
   */
  disabled?: {
    [k: string]: (
      | AnalysisNode
      | SingularTestNode
      | HookNode
      | ModelNode
      | RPCNode
      | SqlNode
      | GenericTestNode
      | SnapshotNode
      | SeedNode
      | SourceDefinition
      | Exposure
      | Metric
      | SemanticModel
    )[];
  } | null;
  /**
   * A mapping fromÂ child nodes to their dependencies
   */
  parent_map?: {
    [k: string]: string[];
  } | null;
  /**
   * A mapping from parent nodes to their dependents
   */
  child_map?: {
    [k: string]: string[];
  } | null;
  /**
   * A mapping from group names to their nodes
   */
  group_map?: {
    [k: string]: string[];
  } | null;
  /**
   * The semantic models defined in the dbt project
   */
  semantic_models: {
    [k: string]: SemanticModel;
  };
}
/**
 * AnalysisNode(database: Union[str, NoneType], schema: str, name: str, resource_type: dbt.node_types.NodeType, package_name: str, path: str, original_file_path: str, unique_id: str, fqn: List[str], alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.nodes.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, group: Union[str, NoneType] = None, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>, relation_name: Union[str, NoneType] = None, raw_code: str = '', language: str = 'sql', refs: List[dbt.contracts.graph.nodes.RefArgs] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.nodes.DependsOn = <factory>, compiled_path: Union[str, NoneType] = None, compiled: bool = False, compiled_code: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.nodes.InjectedCTE] = <factory>, _pre_injected_sql: Union[str, NoneType] = None, contract: dbt.contracts.graph.nodes.Contract = <factory>)
 */
export interface AnalysisNode {
  database?: string | null;
  schema: string;
  name: string;
  resource_type: 'analysis';
  package_name: string;
  path: string;
  original_file_path: string;
  unique_id: string;
  fqn: string[];
  alias: string;
  checksum: FileHash;
  /**
   * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, group: Union[str, NoneType] = None, materialized: str = 'view', incremental_strategy: Union[str, NoneType] = None, persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, full_refresh: Union[bool, NoneType] = None, unique_key: Union[str, List[str], NoneType] = None, on_schema_change: Union[str, NoneType] = 'ignore', on_configuration_change: dbt.contracts.graph.model_config.OnConfigurationChangeOption = <factory>, grants: Dict[str, Any] = <factory>, packages: List[str] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, contract: dbt.contracts.graph.model_config.ContractConfig = <factory>)
   */
  config?: {
    enabled?: boolean;
    alias?: string | null;
    schema?: string | null;
    database?: string | null;
    tags?: string[] | string;
    meta?: {
      [k: string]: unknown;
    };
    group?: string | null;
    materialized?: string;
    incremental_strategy?: string | null;
    persist_docs?: {
      [k: string]: unknown;
    };
    'post-hook'?: Hook[];
    'pre-hook'?: Hook[];
    quoting?: {
      [k: string]: unknown;
    };
    column_types?: {
      [k: string]: unknown;
    };
    full_refresh?: boolean | null;
    unique_key?: string | string[] | null;
    on_schema_change?: string | null;
    on_configuration_change?: 'apply' | 'continue' | 'fail';
    grants?: {
      [k: string]: unknown;
    };
    packages?: string[];
    /**
     * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
     */
    docs?: {
      show?: boolean;
      node_color?: string | null;
    };
    /**
     * ContractConfig(enforced: bool = False)
     */
    contract?: {
      enforced?: boolean;
    };
    [k: string]: unknown;
  };
  tags?: string[];
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  group?: string | null;
  /**
   * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
   */
  docs?: {
    show?: boolean;
    node_color?: string | null;
  };
  patch_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
  relation_name?: string | null;
  raw_code?: string;
  language?: string;
  refs?: RefArgs[];
  sources?: string[][];
  metrics?: string[][];
  /**
   * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
   */
  depends_on?: {
    macros?: string[];
    nodes?: string[];
  };
  compiled_path?: string | null;
  compiled?: boolean;
  compiled_code?: string | null;
  extra_ctes_injected?: boolean;
  extra_ctes?: InjectedCTE[];
  /**
   * Contract(enforced: bool = False, checksum: Union[str, NoneType] = None)
   */
  contract?: {
    enforced?: boolean;
    checksum?: string | null;
  };
}
/**
 * FileHash(name: str, checksum: str)
 */
export interface FileHash {
  name: string;
  checksum: string;
}
/**
 * Hook(sql: str, transaction: bool = True, index: Union[int, NoneType] = None)
 */
export interface Hook {
  sql: string;
  transaction?: boolean;
  index?: number | null;
}
/**
 * Used in all ManifestNodes and SourceDefinition
 */
export interface ColumnInfo {
  name: string;
  description?: string;
  meta?: {
    [k: string]: unknown;
  };
  data_type?: string | null;
  constraints?: ColumnLevelConstraint[];
  quote?: boolean | null;
  tags?: string[];
  [k: string]: unknown;
}
/**
 * ColumnLevelConstraint(type: dbt.contracts.graph.nodes.ConstraintType, name: Union[str, NoneType] = None, expression: Union[str, NoneType] = None, warn_unenforced: bool = True, warn_unsupported: bool = True)
 */
export interface ColumnLevelConstraint {
  type:
    | 'check'
    | 'not_null'
    | 'unique'
    | 'primary_key'
    | 'foreign_key'
    | 'custom';
  name?: string | null;
  expression?: string | null;
  warn_unenforced?: boolean;
  warn_unsupported?: boolean;
}
/**
 * RefArgs(name: str, package: Union[str, NoneType] = None, version: Union[str, float, NoneType] = None)
 */
export interface RefArgs {
  name: string;
  package?: string | null;
  version?: string | number | null;
}
/**
 * Used in CompiledNodes as part of ephemeral model processing
 */
export interface InjectedCTE {
  id: string;
  sql: string;
}
/**
 * SingularTestNode(database: Union[str, NoneType], schema: str, name: str, resource_type: dbt.node_types.NodeType, package_name: str, path: str, original_file_path: str, unique_id: str, fqn: List[str], alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.TestConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.nodes.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, group: Union[str, NoneType] = None, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>, relation_name: Union[str, NoneType] = None, raw_code: str = '', language: str = 'sql', refs: List[dbt.contracts.graph.nodes.RefArgs] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.nodes.DependsOn = <factory>, compiled_path: Union[str, NoneType] = None, compiled: bool = False, compiled_code: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.nodes.InjectedCTE] = <factory>, _pre_injected_sql: Union[str, NoneType] = None, contract: dbt.contracts.graph.nodes.Contract = <factory>)
 */
export interface SingularTestNode {
  database?: string | null;
  schema: string;
  name: string;
  resource_type: 'test';
  package_name: string;
  path: string;
  original_file_path: string;
  unique_id: string;
  fqn: string[];
  alias: string;
  checksum: FileHash;
  /**
   * TestConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = 'dbt_test__audit', database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, group: Union[str, NoneType] = None, materialized: str = 'test', severity: dbt.contracts.graph.model_config.Severity = 'ERROR', store_failures: Union[bool, NoneType] = None, where: Union[str, NoneType] = None, limit: Union[int, NoneType] = None, fail_calc: str = 'count(*)', warn_if: str = '!= 0', error_if: str = '!= 0')
   */
  config?: {
    enabled?: boolean;
    alias?: string | null;
    schema?: string | null;
    database?: string | null;
    tags?: string[] | string;
    meta?: {
      [k: string]: unknown;
    };
    group?: string | null;
    materialized?: string;
    severity?: string;
    store_failures?: boolean | null;
    where?: string | null;
    limit?: number | null;
    fail_calc?: string;
    warn_if?: string;
    error_if?: string;
    [k: string]: unknown;
  };
  tags?: string[];
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  group?: string | null;
  /**
   * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
   */
  docs?: {
    show?: boolean;
    node_color?: string | null;
  };
  patch_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
  relation_name?: string | null;
  raw_code?: string;
  language?: string;
  refs?: RefArgs[];
  sources?: string[][];
  metrics?: string[][];
  /**
   * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
   */
  depends_on?: {
    macros?: string[];
    nodes?: string[];
  };
  compiled_path?: string | null;
  compiled?: boolean;
  compiled_code?: string | null;
  extra_ctes_injected?: boolean;
  extra_ctes?: InjectedCTE[];
  /**
   * Contract(enforced: bool = False, checksum: Union[str, NoneType] = None)
   */
  contract?: {
    enforced?: boolean;
    checksum?: string | null;
  };
}
/**
 * HookNode(database: Union[str, NoneType], schema: str, name: str, resource_type: dbt.node_types.NodeType, package_name: str, path: str, original_file_path: str, unique_id: str, fqn: List[str], alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.nodes.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, group: Union[str, NoneType] = None, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>, relation_name: Union[str, NoneType] = None, raw_code: str = '', language: str = 'sql', refs: List[dbt.contracts.graph.nodes.RefArgs] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.nodes.DependsOn = <factory>, compiled_path: Union[str, NoneType] = None, compiled: bool = False, compiled_code: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.nodes.InjectedCTE] = <factory>, _pre_injected_sql: Union[str, NoneType] = None, contract: dbt.contracts.graph.nodes.Contract = <factory>, index: Union[int, NoneType] = None)
 */
export interface HookNode {
  database?: string | null;
  schema: string;
  name: string;
  resource_type: 'operation';
  package_name: string;
  path: string;
  original_file_path: string;
  unique_id: string;
  fqn: string[];
  alias: string;
  checksum: FileHash;
  /**
   * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, group: Union[str, NoneType] = None, materialized: str = 'view', incremental_strategy: Union[str, NoneType] = None, persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, full_refresh: Union[bool, NoneType] = None, unique_key: Union[str, List[str], NoneType] = None, on_schema_change: Union[str, NoneType] = 'ignore', on_configuration_change: dbt.contracts.graph.model_config.OnConfigurationChangeOption = <factory>, grants: Dict[str, Any] = <factory>, packages: List[str] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, contract: dbt.contracts.graph.model_config.ContractConfig = <factory>)
   */
  config?: {
    enabled?: boolean;
    alias?: string | null;
    schema?: string | null;
    database?: string | null;
    tags?: string[] | string;
    meta?: {
      [k: string]: unknown;
    };
    group?: string | null;
    materialized?: string;
    incremental_strategy?: string | null;
    persist_docs?: {
      [k: string]: unknown;
    };
    'post-hook'?: Hook[];
    'pre-hook'?: Hook[];
    quoting?: {
      [k: string]: unknown;
    };
    column_types?: {
      [k: string]: unknown;
    };
    full_refresh?: boolean | null;
    unique_key?: string | string[] | null;
    on_schema_change?: string | null;
    on_configuration_change?: 'apply' | 'continue' | 'fail';
    grants?: {
      [k: string]: unknown;
    };
    packages?: string[];
    /**
     * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
     */
    docs?: {
      show?: boolean;
      node_color?: string | null;
    };
    /**
     * ContractConfig(enforced: bool = False)
     */
    contract?: {
      enforced?: boolean;
    };
    [k: string]: unknown;
  };
  tags?: string[];
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  group?: string | null;
  /**
   * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
   */
  docs?: {
    show?: boolean;
    node_color?: string | null;
  };
  patch_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
  relation_name?: string | null;
  raw_code?: string;
  language?: string;
  refs?: RefArgs[];
  sources?: string[][];
  metrics?: string[][];
  /**
   * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
   */
  depends_on?: {
    macros?: string[];
    nodes?: string[];
  };
  compiled_path?: string | null;
  compiled?: boolean;
  compiled_code?: string | null;
  extra_ctes_injected?: boolean;
  extra_ctes?: InjectedCTE[];
  /**
   * Contract(enforced: bool = False, checksum: Union[str, NoneType] = None)
   */
  contract?: {
    enforced?: boolean;
    checksum?: string | null;
  };
  index?: number | null;
}
/**
 * ModelNode(database: Union[str, NoneType], schema: str, name: str, resource_type: dbt.node_types.NodeType, package_name: str, path: str, original_file_path: str, unique_id: str, fqn: List[str], alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.nodes.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, group: Union[str, NoneType] = None, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>, relation_name: Union[str, NoneType] = None, raw_code: str = '', language: str = 'sql', refs: List[dbt.contracts.graph.nodes.RefArgs] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.nodes.DependsOn = <factory>, compiled_path: Union[str, NoneType] = None, compiled: bool = False, compiled_code: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.nodes.InjectedCTE] = <factory>, _pre_injected_sql: Union[str, NoneType] = None, contract: dbt.contracts.graph.nodes.Contract = <factory>, access: dbt.node_types.AccessType = <AccessType.Protected: 'protected'>, constraints: List[dbt.contracts.graph.nodes.ModelLevelConstraint] = <factory>, version: Union[str, float, NoneType] = None, latest_version: Union[str, float, NoneType] = None, deprecation_date: Union[datetime.datetime, NoneType] = None, defer_relation: Union[dbt.contracts.graph.nodes.DeferRelation, NoneType] = None)
 */
export interface ModelNode {
  database?: string | null;
  schema: string;
  name: string;
  resource_type: 'model';
  package_name: string;
  path: string;
  original_file_path: string;
  unique_id: string;
  fqn: string[];
  alias: string;
  checksum: FileHash;
  /**
   * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, group: Union[str, NoneType] = None, materialized: str = 'view', incremental_strategy: Union[str, NoneType] = None, persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, full_refresh: Union[bool, NoneType] = None, unique_key: Union[str, List[str], NoneType] = None, on_schema_change: Union[str, NoneType] = 'ignore', on_configuration_change: dbt.contracts.graph.model_config.OnConfigurationChangeOption = <factory>, grants: Dict[str, Any] = <factory>, packages: List[str] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, contract: dbt.contracts.graph.model_config.ContractConfig = <factory>)
   */
  config?: {
    enabled?: boolean;
    alias?: string | null;
    schema?: string | null;
    database?: string | null;
    tags?: string[] | string;
    meta?: {
      [k: string]: unknown;
    };
    group?: string | null;
    materialized?: string;
    incremental_strategy?: string | null;
    persist_docs?: {
      [k: string]: unknown;
    };
    'post-hook'?: Hook[];
    'pre-hook'?: Hook[];
    quoting?: {
      [k: string]: unknown;
    };
    column_types?: {
      [k: string]: unknown;
    };
    full_refresh?: boolean | null;
    unique_key?: string | string[] | null;
    on_schema_change?: string | null;
    on_configuration_change?: 'apply' | 'continue' | 'fail';
    grants?: {
      [k: string]: unknown;
    };
    packages?: string[];
    /**
     * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
     */
    docs?: {
      show?: boolean;
      node_color?: string | null;
    };
    /**
     * ContractConfig(enforced: bool = False)
     */
    contract?: {
      enforced?: boolean;
    };
    [k: string]: unknown;
  };
  tags?: string[];
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  group?: string | null;
  /**
   * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
   */
  docs?: {
    show?: boolean;
    node_color?: string | null;
  };
  patch_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
  relation_name?: string | null;
  raw_code?: string;
  language?: string;
  refs?: RefArgs[];
  sources?: string[][];
  metrics?: string[][];
  /**
   * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
   */
  depends_on?: {
    macros?: string[];
    nodes?: string[];
  };
  compiled_path?: string | null;
  compiled?: boolean;
  compiled_code?: string | null;
  extra_ctes_injected?: boolean;
  extra_ctes?: InjectedCTE[];
  /**
   * Contract(enforced: bool = False, checksum: Union[str, NoneType] = None)
   */
  contract?: {
    enforced?: boolean;
    checksum?: string | null;
  };
  access?: 'protected' | 'private' | 'public';
  constraints?: ModelLevelConstraint[];
  version?: string | number | null;
  latest_version?: string | number | null;
  deprecation_date?: string | null;
  defer_relation?: DeferRelation | null;
}
/**
 * ModelLevelConstraint(type: dbt.contracts.graph.nodes.ConstraintType, name: Union[str, NoneType] = None, expression: Union[str, NoneType] = None, warn_unenforced: bool = True, warn_unsupported: bool = True, columns: List[str] = <factory>)
 */
export interface ModelLevelConstraint {
  type:
    | 'check'
    | 'not_null'
    | 'unique'
    | 'primary_key'
    | 'foreign_key'
    | 'custom';
  name?: string | null;
  expression?: string | null;
  warn_unenforced?: boolean;
  warn_unsupported?: boolean;
  columns?: string[];
}
/**
 * DeferRelation(database: Union[str, NoneType], schema: str, alias: str, relation_name: Union[str, NoneType])
 */
export interface DeferRelation {
  database?: string | null;
  schema: string;
  alias: string;
  relation_name?: string | null;
}
/**
 * RPCNode(database: Union[str, NoneType], schema: str, name: str, resource_type: dbt.node_types.NodeType, package_name: str, path: str, original_file_path: str, unique_id: str, fqn: List[str], alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.nodes.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, group: Union[str, NoneType] = None, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>, relation_name: Union[str, NoneType] = None, raw_code: str = '', language: str = 'sql', refs: List[dbt.contracts.graph.nodes.RefArgs] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.nodes.DependsOn = <factory>, compiled_path: Union[str, NoneType] = None, compiled: bool = False, compiled_code: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.nodes.InjectedCTE] = <factory>, _pre_injected_sql: Union[str, NoneType] = None, contract: dbt.contracts.graph.nodes.Contract = <factory>)
 */
export interface RPCNode {
  database?: string | null;
  schema: string;
  name: string;
  resource_type: 'rpc';
  package_name: string;
  path: string;
  original_file_path: string;
  unique_id: string;
  fqn: string[];
  alias: string;
  checksum: FileHash;
  /**
   * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, group: Union[str, NoneType] = None, materialized: str = 'view', incremental_strategy: Union[str, NoneType] = None, persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, full_refresh: Union[bool, NoneType] = None, unique_key: Union[str, List[str], NoneType] = None, on_schema_change: Union[str, NoneType] = 'ignore', on_configuration_change: dbt.contracts.graph.model_config.OnConfigurationChangeOption = <factory>, grants: Dict[str, Any] = <factory>, packages: List[str] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, contract: dbt.contracts.graph.model_config.ContractConfig = <factory>)
   */
  config?: {
    enabled?: boolean;
    alias?: string | null;
    schema?: string | null;
    database?: string | null;
    tags?: string[] | string;
    meta?: {
      [k: string]: unknown;
    };
    group?: string | null;
    materialized?: string;
    incremental_strategy?: string | null;
    persist_docs?: {
      [k: string]: unknown;
    };
    'post-hook'?: Hook[];
    'pre-hook'?: Hook[];
    quoting?: {
      [k: string]: unknown;
    };
    column_types?: {
      [k: string]: unknown;
    };
    full_refresh?: boolean | null;
    unique_key?: string | string[] | null;
    on_schema_change?: string | null;
    on_configuration_change?: 'apply' | 'continue' | 'fail';
    grants?: {
      [k: string]: unknown;
    };
    packages?: string[];
    /**
     * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
     */
    docs?: {
      show?: boolean;
      node_color?: string | null;
    };
    /**
     * ContractConfig(enforced: bool = False)
     */
    contract?: {
      enforced?: boolean;
    };
    [k: string]: unknown;
  };
  tags?: string[];
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  group?: string | null;
  /**
   * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
   */
  docs?: {
    show?: boolean;
    node_color?: string | null;
  };
  patch_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
  relation_name?: string | null;
  raw_code?: string;
  language?: string;
  refs?: RefArgs[];
  sources?: string[][];
  metrics?: string[][];
  /**
   * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
   */
  depends_on?: {
    macros?: string[];
    nodes?: string[];
  };
  compiled_path?: string | null;
  compiled?: boolean;
  compiled_code?: string | null;
  extra_ctes_injected?: boolean;
  extra_ctes?: InjectedCTE[];
  /**
   * Contract(enforced: bool = False, checksum: Union[str, NoneType] = None)
   */
  contract?: {
    enforced?: boolean;
    checksum?: string | null;
  };
}
/**
 * SqlNode(database: Union[str, NoneType], schema: str, name: str, resource_type: dbt.node_types.NodeType, package_name: str, path: str, original_file_path: str, unique_id: str, fqn: List[str], alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.nodes.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, group: Union[str, NoneType] = None, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>, relation_name: Union[str, NoneType] = None, raw_code: str = '', language: str = 'sql', refs: List[dbt.contracts.graph.nodes.RefArgs] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.nodes.DependsOn = <factory>, compiled_path: Union[str, NoneType] = None, compiled: bool = False, compiled_code: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.nodes.InjectedCTE] = <factory>, _pre_injected_sql: Union[str, NoneType] = None, contract: dbt.contracts.graph.nodes.Contract = <factory>)
 */
export interface SqlNode {
  database?: string | null;
  schema: string;
  name: string;
  resource_type: 'sql_operation';
  package_name: string;
  path: string;
  original_file_path: string;
  unique_id: string;
  fqn: string[];
  alias: string;
  checksum: FileHash;
  /**
   * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, group: Union[str, NoneType] = None, materialized: str = 'view', incremental_strategy: Union[str, NoneType] = None, persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, full_refresh: Union[bool, NoneType] = None, unique_key: Union[str, List[str], NoneType] = None, on_schema_change: Union[str, NoneType] = 'ignore', on_configuration_change: dbt.contracts.graph.model_config.OnConfigurationChangeOption = <factory>, grants: Dict[str, Any] = <factory>, packages: List[str] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, contract: dbt.contracts.graph.model_config.ContractConfig = <factory>)
   */
  config?: {
    enabled?: boolean;
    alias?: string | null;
    schema?: string | null;
    database?: string | null;
    tags?: string[] | string;
    meta?: {
      [k: string]: unknown;
    };
    group?: string | null;
    materialized?: string;
    incremental_strategy?: string | null;
    persist_docs?: {
      [k: string]: unknown;
    };
    'post-hook'?: Hook[];
    'pre-hook'?: Hook[];
    quoting?: {
      [k: string]: unknown;
    };
    column_types?: {
      [k: string]: unknown;
    };
    full_refresh?: boolean | null;
    unique_key?: string | string[] | null;
    on_schema_change?: string | null;
    on_configuration_change?: 'apply' | 'continue' | 'fail';
    grants?: {
      [k: string]: unknown;
    };
    packages?: string[];
    /**
     * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
     */
    docs?: {
      show?: boolean;
      node_color?: string | null;
    };
    /**
     * ContractConfig(enforced: bool = False)
     */
    contract?: {
      enforced?: boolean;
    };
    [k: string]: unknown;
  };
  tags?: string[];
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  group?: string | null;
  /**
   * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
   */
  docs?: {
    show?: boolean;
    node_color?: string | null;
  };
  patch_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
  relation_name?: string | null;
  raw_code?: string;
  language?: string;
  refs?: RefArgs[];
  sources?: string[][];
  metrics?: string[][];
  /**
   * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
   */
  depends_on?: {
    macros?: string[];
    nodes?: string[];
  };
  compiled_path?: string | null;
  compiled?: boolean;
  compiled_code?: string | null;
  extra_ctes_injected?: boolean;
  extra_ctes?: InjectedCTE[];
  /**
   * Contract(enforced: bool = False, checksum: Union[str, NoneType] = None)
   */
  contract?: {
    enforced?: boolean;
    checksum?: string | null;
  };
}
/**
 * GenericTestNode(test_metadata: dbt.contracts.graph.nodes.TestMetadata, database: Union[str, NoneType], schema: str, name: str, resource_type: dbt.node_types.NodeType, package_name: str, path: str, original_file_path: str, unique_id: str, fqn: List[str], alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.TestConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.nodes.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, group: Union[str, NoneType] = None, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>, relation_name: Union[str, NoneType] = None, raw_code: str = '', language: str = 'sql', refs: List[dbt.contracts.graph.nodes.RefArgs] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.nodes.DependsOn = <factory>, compiled_path: Union[str, NoneType] = None, compiled: bool = False, compiled_code: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.nodes.InjectedCTE] = <factory>, _pre_injected_sql: Union[str, NoneType] = None, contract: dbt.contracts.graph.nodes.Contract = <factory>, column_name: Union[str, NoneType] = None, file_key_name: Union[str, NoneType] = None, attached_node: Union[str, NoneType] = None)
 */
export interface GenericTestNode {
  test_metadata: TestMetadata;
  database?: string | null;
  schema: string;
  name: string;
  resource_type: 'test';
  package_name: string;
  path: string;
  original_file_path: string;
  unique_id: string;
  fqn: string[];
  alias: string;
  checksum: FileHash;
  /**
   * TestConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = 'dbt_test__audit', database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, group: Union[str, NoneType] = None, materialized: str = 'test', severity: dbt.contracts.graph.model_config.Severity = 'ERROR', store_failures: Union[bool, NoneType] = None, where: Union[str, NoneType] = None, limit: Union[int, NoneType] = None, fail_calc: str = 'count(*)', warn_if: str = '!= 0', error_if: str = '!= 0')
   */
  config?: {
    enabled?: boolean;
    alias?: string | null;
    schema?: string | null;
    database?: string | null;
    tags?: string[] | string;
    meta?: {
      [k: string]: unknown;
    };
    group?: string | null;
    materialized?: string;
    severity?: string;
    store_failures?: boolean | null;
    where?: string | null;
    limit?: number | null;
    fail_calc?: string;
    warn_if?: string;
    error_if?: string;
    [k: string]: unknown;
  };
  tags?: string[];
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  group?: string | null;
  /**
   * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
   */
  docs?: {
    show?: boolean;
    node_color?: string | null;
  };
  patch_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
  relation_name?: string | null;
  raw_code?: string;
  language?: string;
  refs?: RefArgs[];
  sources?: string[][];
  metrics?: string[][];
  /**
   * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
   */
  depends_on?: {
    macros?: string[];
    nodes?: string[];
  };
  compiled_path?: string | null;
  compiled?: boolean;
  compiled_code?: string | null;
  extra_ctes_injected?: boolean;
  extra_ctes?: InjectedCTE[];
  /**
   * Contract(enforced: bool = False, checksum: Union[str, NoneType] = None)
   */
  contract?: {
    enforced?: boolean;
    checksum?: string | null;
  };
  column_name?: string | null;
  file_key_name?: string | null;
  attached_node?: string | null;
}
/**
 * TestMetadata(name: str, kwargs: Dict[str, Any] = <factory>, namespace: Union[str, NoneType] = None)
 */
export interface TestMetadata {
  name: string;
  kwargs?: {
    [k: string]: unknown;
  };
  namespace?: string | null;
}
/**
 * SnapshotNode(database: Union[str, NoneType], schema: str, name: str, resource_type: dbt.node_types.NodeType, package_name: str, path: str, original_file_path: str, unique_id: str, fqn: List[str], alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.SnapshotConfig, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.nodes.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, group: Union[str, NoneType] = None, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>, relation_name: Union[str, NoneType] = None, raw_code: str = '', language: str = 'sql', refs: List[dbt.contracts.graph.nodes.RefArgs] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.nodes.DependsOn = <factory>, compiled_path: Union[str, NoneType] = None, compiled: bool = False, compiled_code: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.nodes.InjectedCTE] = <factory>, _pre_injected_sql: Union[str, NoneType] = None, contract: dbt.contracts.graph.nodes.Contract = <factory>, defer_relation: Union[dbt.contracts.graph.nodes.DeferRelation, NoneType] = None)
 */
export interface SnapshotNode {
  database?: string | null;
  schema: string;
  name: string;
  resource_type: 'snapshot';
  package_name: string;
  path: string;
  original_file_path: string;
  unique_id: string;
  fqn: string[];
  alias: string;
  checksum: FileHash;
  config: SnapshotConfig;
  tags?: string[];
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  group?: string | null;
  /**
   * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
   */
  docs?: {
    show?: boolean;
    node_color?: string | null;
  };
  patch_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
  relation_name?: string | null;
  raw_code?: string;
  language?: string;
  refs?: RefArgs[];
  sources?: string[][];
  metrics?: string[][];
  /**
   * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
   */
  depends_on?: {
    macros?: string[];
    nodes?: string[];
  };
  compiled_path?: string | null;
  compiled?: boolean;
  compiled_code?: string | null;
  extra_ctes_injected?: boolean;
  extra_ctes?: InjectedCTE[];
  /**
   * Contract(enforced: bool = False, checksum: Union[str, NoneType] = None)
   */
  contract?: {
    enforced?: boolean;
    checksum?: string | null;
  };
  defer_relation?: DeferRelation | null;
}
/**
 * SnapshotConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, group: Union[str, NoneType] = None, materialized: str = 'snapshot', incremental_strategy: Union[str, NoneType] = None, persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, full_refresh: Union[bool, NoneType] = None, unique_key: Union[str, NoneType] = None, on_schema_change: Union[str, NoneType] = 'ignore', on_configuration_change: dbt.contracts.graph.model_config.OnConfigurationChangeOption = <factory>, grants: Dict[str, Any] = <factory>, packages: List[str] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, contract: dbt.contracts.graph.model_config.ContractConfig = <factory>, strategy: Union[str, NoneType] = None, target_schema: Union[str, NoneType] = None, target_database: Union[str, NoneType] = None, updated_at: Union[str, NoneType] = None, check_cols: Union[str, List[str], NoneType] = None)
 */
export interface SnapshotConfig {
  enabled?: boolean;
  alias?: string | null;
  schema?: string | null;
  database?: string | null;
  tags?: string[] | string;
  meta?: {
    [k: string]: unknown;
  };
  group?: string | null;
  materialized?: string;
  incremental_strategy?: string | null;
  persist_docs?: {
    [k: string]: unknown;
  };
  'post-hook'?: Hook[];
  'pre-hook'?: Hook[];
  quoting?: {
    [k: string]: unknown;
  };
  column_types?: {
    [k: string]: unknown;
  };
  full_refresh?: boolean | null;
  unique_key?: string | null;
  on_schema_change?: string | null;
  on_configuration_change?: 'apply' | 'continue' | 'fail';
  grants?: {
    [k: string]: unknown;
  };
  packages?: string[];
  /**
   * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
   */
  docs?: {
    show?: boolean;
    node_color?: string | null;
  };
  /**
   * ContractConfig(enforced: bool = False)
   */
  contract?: {
    enforced?: boolean;
  };
  strategy?: string | null;
  target_schema?: string | null;
  target_database?: string | null;
  updated_at?: string | null;
  check_cols?: string | string[] | null;
  [k: string]: unknown;
}
/**
 * SeedNode(database: Union[str, NoneType], schema: str, name: str, resource_type: dbt.node_types.NodeType, package_name: str, path: str, original_file_path: str, unique_id: str, fqn: List[str], alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.SeedConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.nodes.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, group: Union[str, NoneType] = None, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>, relation_name: Union[str, NoneType] = None, raw_code: str = '', root_path: Union[str, NoneType] = None, depends_on: dbt.contracts.graph.nodes.MacroDependsOn = <factory>, defer_relation: Union[dbt.contracts.graph.nodes.DeferRelation, NoneType] = None)
 */
export interface SeedNode {
  database?: string | null;
  schema: string;
  name: string;
  resource_type: 'seed';
  package_name: string;
  path: string;
  original_file_path: string;
  unique_id: string;
  fqn: string[];
  alias: string;
  checksum: FileHash;
  /**
   * SeedConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, group: Union[str, NoneType] = None, materialized: str = 'seed', incremental_strategy: Union[str, NoneType] = None, persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, full_refresh: Union[bool, NoneType] = None, unique_key: Union[str, List[str], NoneType] = None, on_schema_change: Union[str, NoneType] = 'ignore', on_configuration_change: dbt.contracts.graph.model_config.OnConfigurationChangeOption = <factory>, grants: Dict[str, Any] = <factory>, packages: List[str] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, contract: dbt.contracts.graph.model_config.ContractConfig = <factory>, quote_columns: Union[bool, NoneType] = None)
   */
  config?: {
    enabled?: boolean;
    alias?: string | null;
    schema?: string | null;
    database?: string | null;
    tags?: string[] | string;
    meta?: {
      [k: string]: unknown;
    };
    group?: string | null;
    materialized?: string;
    incremental_strategy?: string | null;
    persist_docs?: {
      [k: string]: unknown;
    };
    'post-hook'?: Hook[];
    'pre-hook'?: Hook[];
    quoting?: {
      [k: string]: unknown;
    };
    column_types?: {
      [k: string]: unknown;
    };
    full_refresh?: boolean | null;
    unique_key?: string | string[] | null;
    on_schema_change?: string | null;
    on_configuration_change?: 'apply' | 'continue' | 'fail';
    grants?: {
      [k: string]: unknown;
    };
    packages?: string[];
    /**
     * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
     */
    docs?: {
      show?: boolean;
      node_color?: string | null;
    };
    /**
     * ContractConfig(enforced: bool = False)
     */
    contract?: {
      enforced?: boolean;
    };
    quote_columns?: boolean | null;
    [k: string]: unknown;
  };
  tags?: string[];
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  group?: string | null;
  /**
   * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
   */
  docs?: {
    show?: boolean;
    node_color?: string | null;
  };
  patch_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
  relation_name?: string | null;
  raw_code?: string;
  root_path?: string | null;
  /**
   * Used only in the Macro class
   */
  depends_on?: {
    macros?: string[];
  };
  defer_relation?: DeferRelation | null;
}
/**
 * SourceDefinition(database: Union[str, NoneType], schema: str, name: str, resource_type: dbt.node_types.NodeType, package_name: str, path: str, original_file_path: str, unique_id: str, fqn: List[str], source_name: str, source_description: str, loader: str, identifier: str, _event_status: Dict[str, Any] = <factory>, quoting: dbt.contracts.graph.unparsed.Quoting = <factory>, loaded_at_field: Union[str, NoneType] = None, freshness: Union[dbt.contracts.graph.unparsed.FreshnessThreshold, NoneType] = None, external: Union[dbt.contracts.graph.unparsed.ExternalTable, NoneType] = None, description: str = '', columns: Dict[str, dbt.contracts.graph.nodes.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, source_meta: Dict[str, Any] = <factory>, tags: List[str] = <factory>, config: dbt.contracts.graph.model_config.SourceConfig = <factory>, patch_path: Union[str, NoneType] = None, unrendered_config: Dict[str, Any] = <factory>, relation_name: Union[str, NoneType] = None, created_at: float = <factory>)
 */
export interface SourceDefinition {
  database?: string | null;
  schema: string;
  name: string;
  resource_type: 'source';
  package_name: string;
  path: string;
  original_file_path: string;
  unique_id: string;
  fqn: string[];
  source_name: string;
  source_description: string;
  loader: string;
  identifier: string;
  /**
   * Quoting(database: Union[bool, NoneType] = None, schema: Union[bool, NoneType] = None, identifier: Union[bool, NoneType] = None, column: Union[bool, NoneType] = None)
   */
  quoting?: {
    database?: boolean | null;
    schema?: boolean | null;
    identifier?: boolean | null;
    column?: boolean | null;
  };
  loaded_at_field?: string | null;
  freshness?: FreshnessThreshold | null;
  external?: ExternalTable | null;
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  source_meta?: {
    [k: string]: unknown;
  };
  tags?: string[];
  /**
   * SourceConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True)
   */
  config?: {
    enabled?: boolean;
    [k: string]: unknown;
  };
  patch_path?: string | null;
  unrendered_config?: {
    [k: string]: unknown;
  };
  relation_name?: string | null;
  created_at?: number;
}
/**
 * FreshnessThreshold(warn_after: Union[dbt.contracts.graph.unparsed.Time, NoneType] = <factory>, error_after: Union[dbt.contracts.graph.unparsed.Time, NoneType] = <factory>, filter: Union[str, NoneType] = None)
 */
export interface FreshnessThreshold {
  warn_after?: Time | null;
  error_after?: Time | null;
  filter?: string | null;
}
/**
 * Time(count: Union[int, NoneType] = None, period: Union[dbt.contracts.graph.unparsed.TimePeriod, NoneType] = None)
 */
export interface Time {
  count?: number | null;
  period?: ('minute' | 'hour' | 'day') | null;
}
/**
 * ExternalTable(_extra: Dict[str, Any] = <factory>, location: Union[str, NoneType] = None, file_format: Union[str, NoneType] = None, row_format: Union[str, NoneType] = None, tbl_properties: Union[str, NoneType] = None, partitions: Union[List[str], List[dbt.contracts.graph.unparsed.ExternalPartition], NoneType] = None)
 */
export interface ExternalTable {
  location?: string | null;
  file_format?: string | null;
  row_format?: string | null;
  tbl_properties?: string | null;
  partitions?: string[] | ExternalPartition[] | null;
  [k: string]: unknown;
}
/**
 * ExternalPartition(_extra: Dict[str, Any] = <factory>, name: str = '', description: str = '', data_type: str = '', meta: Dict[str, Any] = <factory>)
 */
export interface ExternalPartition {
  name?: string;
  description?: string;
  data_type?: string;
  meta?: {
    [k: string]: unknown;
  };
  [k: string]: unknown;
}
/**
 * Macro(name: str, resource_type: dbt.node_types.NodeType, package_name: str, path: str, original_file_path: str, unique_id: str, macro_sql: str, depends_on: dbt.contracts.graph.nodes.MacroDependsOn = <factory>, description: str = '', meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, arguments: List[dbt.contracts.graph.unparsed.MacroArgument] = <factory>, created_at: float = <factory>, supported_languages: Union[List[dbt.node_types.ModelLanguage], NoneType] = None)
 */
export interface Macro {
  name: string;
  resource_type: 'macro';
  package_name: string;
  path: string;
  original_file_path: string;
  unique_id: string;
  macro_sql: string;
  /**
   * Used only in the Macro class
   */
  depends_on?: {
    macros?: string[];
  };
  description?: string;
  meta?: {
    [k: string]: unknown;
  };
  /**
   * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
   */
  docs?: {
    show?: boolean;
    node_color?: string | null;
  };
  patch_path?: string | null;
  arguments?: MacroArgument[];
  created_at?: number;
  supported_languages?: ('python' | 'sql')[] | null;
}
/**
 * MacroArgument(name: str, type: Union[str, NoneType] = None, description: str = '')
 */
export interface MacroArgument {
  name: string;
  type?: string | null;
  description?: string;
}
/**
 * Documentation(name: str, resource_type: dbt.node_types.NodeType, package_name: str, path: str, original_file_path: str, unique_id: str, block_contents: str)
 */
export interface Documentation {
  name: string;
  resource_type: 'doc';
  package_name: string;
  path: string;
  original_file_path: string;
  unique_id: string;
  block_contents: string;
}
/**
 * Exposure(name: str, resource_type: dbt.node_types.NodeType, package_name: str, path: str, original_file_path: str, unique_id: str, fqn: List[str], type: dbt.contracts.graph.unparsed.ExposureType, owner: dbt.contracts.graph.unparsed.Owner, description: str = '', label: Union[str, NoneType] = None, maturity: Union[dbt.contracts.graph.unparsed.MaturityType, NoneType] = None, meta: Dict[str, Any] = <factory>, tags: List[str] = <factory>, config: dbt.contracts.graph.model_config.ExposureConfig = <factory>, unrendered_config: Dict[str, Any] = <factory>, url: Union[str, NoneType] = None, depends_on: dbt.contracts.graph.nodes.DependsOn = <factory>, refs: List[dbt.contracts.graph.nodes.RefArgs] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, created_at: float = <factory>)
 */
export interface Exposure {
  name: string;
  resource_type: 'exposure';
  package_name: string;
  path: string;
  original_file_path: string;
  unique_id: string;
  fqn: string[];
  type: 'dashboard' | 'notebook' | 'analysis' | 'ml' | 'application';
  owner: Owner;
  description?: string;
  label?: string | null;
  maturity?: ('low' | 'medium' | 'high') | null;
  meta?: {
    [k: string]: unknown;
  };
  tags?: string[];
  /**
   * ExposureConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True)
   */
  config?: {
    enabled?: boolean;
    [k: string]: unknown;
  };
  unrendered_config?: {
    [k: string]: unknown;
  };
  url?: string | null;
  /**
   * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
   */
  depends_on?: {
    macros?: string[];
    nodes?: string[];
  };
  refs?: RefArgs[];
  sources?: string[][];
  metrics?: string[][];
  created_at?: number;
}
/**
 * Owner(_extra: Dict[str, Any] = <factory>, email: Union[str, NoneType] = None, name: Union[str, NoneType] = None)
 */
export interface Owner {
  email?: string | null;
  name?: string | null;
  [k: string]: unknown;
}
/**
 * Metric(name: str, resource_type: dbt.node_types.NodeType, package_name: str, path: str, original_file_path: str, unique_id: str, fqn: List[str], description: str, label: str, type: dbt_semantic_interfaces.type_enums.metric_type.MetricType, type_params: dbt.contracts.graph.nodes.MetricTypeParams, filter: Union[dbt.contracts.graph.nodes.WhereFilter, NoneType] = None, metadata: Union[dbt.contracts.graph.semantic_models.SourceFileMetadata, NoneType] = None, meta: Dict[str, Any] = <factory>, tags: List[str] = <factory>, config: dbt.contracts.graph.model_config.MetricConfig = <factory>, unrendered_config: Dict[str, Any] = <factory>, sources: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.nodes.DependsOn = <factory>, refs: List[dbt.contracts.graph.nodes.RefArgs] = <factory>, metrics: List[List[str]] = <factory>, created_at: float = <factory>, group: Union[str, NoneType] = None)
 */
export interface Metric {
  name: string;
  resource_type: 'metric';
  package_name: string;
  path: string;
  original_file_path: string;
  unique_id: string;
  fqn: string[];
  description: string;
  label: string;
  type: 'simple' | 'ratio' | 'cumulative' | 'derived';
  type_params: MetricTypeParams;
  filter?: WhereFilter | null;
  metadata?: SourceFileMetadata | null;
  meta?: {
    [k: string]: unknown;
  };
  tags?: string[];
  /**
   * MetricConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, group: Union[str, NoneType] = None)
   */
  config?: {
    enabled?: boolean;
    group?: string | null;
    [k: string]: unknown;
  };
  unrendered_config?: {
    [k: string]: unknown;
  };
  sources?: string[][];
  /**
   * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
   */
  depends_on?: {
    macros?: string[];
    nodes?: string[];
  };
  refs?: RefArgs[];
  metrics?: string[][];
  created_at?: number;
  group?: string | null;
}
/**
 * MetricTypeParams(measure: Union[dbt.contracts.graph.nodes.MetricInputMeasure, NoneType] = None, input_measures: List[dbt.contracts.graph.nodes.MetricInputMeasure] = <factory>, numerator: Union[dbt.contracts.graph.nodes.MetricInput, NoneType] = None, denominator: Union[dbt.contracts.graph.nodes.MetricInput, NoneType] = None, expr: Union[str, NoneType] = None, window: Union[dbt.contracts.graph.nodes.MetricTimeWindow, NoneType] = None, grain_to_date: Union[dbt_semantic_interfaces.type_enums.time_granularity.TimeGranularity, NoneType] = None, metrics: Union[List[dbt.contracts.graph.nodes.MetricInput], NoneType] = None)
 */
export interface MetricTypeParams {
  measure?: MetricInputMeasure | null;
  input_measures?: MetricInputMeasure[];
  numerator?: MetricInput | null;
  denominator?: MetricInput | null;
  expr?: string | null;
  window?: MetricTimeWindow | null;
  grain_to_date?: ('day' | 'week' | 'month' | 'quarter' | 'year') | null;
  metrics?: MetricInput[] | null;
}
/**
 * MetricInputMeasure(name: str, filter: Union[dbt.contracts.graph.nodes.WhereFilter, NoneType] = None, alias: Union[str, NoneType] = None)
 */
export interface MetricInputMeasure {
  name: string;
  filter?: WhereFilter | null;
  alias?: string | null;
}
/**
 * WhereFilter(where_sql_template: str)
 */
export interface WhereFilter {
  where_sql_template: string;
}
/**
 * MetricInput(name: str, filter: Union[dbt.contracts.graph.nodes.WhereFilter, NoneType] = None, alias: Union[str, NoneType] = None, offset_window: Union[dbt.contracts.graph.nodes.MetricTimeWindow, NoneType] = None, offset_to_grain: Union[dbt_semantic_interfaces.type_enums.time_granularity.TimeGranularity, NoneType] = None)
 */
export interface MetricInput {
  name: string;
  filter?: WhereFilter | null;
  alias?: string | null;
  offset_window?: MetricTimeWindow | null;
  offset_to_grain?: ('day' | 'week' | 'month' | 'quarter' | 'year') | null;
}
/**
 * MetricTimeWindow(count: int, granularity: dbt_semantic_interfaces.type_enums.time_granularity.TimeGranularity)
 */
export interface MetricTimeWindow {
  count: number;
  granularity: 'day' | 'week' | 'month' | 'quarter' | 'year';
}
/**
 * Provides file context about what something was created from.
 *
 *     Implementation of the dbt-semantic-interfaces `Metadata` protocol
 *
 */
export interface SourceFileMetadata {
  repo_file_path: string;
  file_slice: FileSlice;
}
/**
 * Provides file slice level context about what something was created from.
 *
 *     Implementation of the dbt-semantic-interfaces `FileSlice` protocol
 *
 */
export interface FileSlice {
  filename: string;
  content: string;
  start_line_number: number;
  end_line_number: number;
}
/**
 * Group(name: str, resource_type: dbt.node_types.NodeType, package_name: str, path: str, original_file_path: str, unique_id: str, owner: dbt.contracts.graph.unparsed.Owner)
 */
export interface Group {
  name: string;
  resource_type: 'group';
  package_name: string;
  path: string;
  original_file_path: string;
  unique_id: string;
  owner: Owner;
}
/**
 * SemanticModel(name: str, resource_type: dbt.node_types.NodeType, package_name: str, path: str, original_file_path: str, unique_id: str, fqn: List[str], model: str, node_relation: Union[dbt.contracts.graph.nodes.NodeRelation, NoneType], description: Union[str, NoneType] = None, defaults: Union[dbt.contracts.graph.semantic_models.Defaults, NoneType] = None, entities: Sequence[dbt.contracts.graph.semantic_models.Entity] = <factory>, measures: Sequence[dbt.contracts.graph.semantic_models.Measure] = <factory>, dimensions: Sequence[dbt.contracts.graph.semantic_models.Dimension] = <factory>, metadata: Union[dbt.contracts.graph.semantic_models.SourceFileMetadata, NoneType] = None, depends_on: dbt.contracts.graph.nodes.DependsOn = <factory>, refs: List[dbt.contracts.graph.nodes.RefArgs] = <factory>, created_at: float = <factory>, config: dbt.contracts.graph.model_config.SemanticModelConfig = <factory>, primary_entity: Union[str, NoneType] = None)
 */
export interface SemanticModel {
  name: string;
  resource_type:
    | 'model'
    | 'analysis'
    | 'test'
    | 'snapshot'
    | 'operation'
    | 'seed'
    | 'rpc'
    | 'sql_operation'
    | 'doc'
    | 'source'
    | 'macro'
    | 'exposure'
    | 'metric'
    | 'group'
    | 'semantic_model';
  package_name: string;
  path: string;
  original_file_path: string;
  unique_id: string;
  fqn: string[];
  model: string;
  node_relation?: NodeRelation | null;
  description?: string | null;
  defaults?: Defaults | null;
  entities?: Entity[];
  measures?: Measure[];
  dimensions?: Dimension[];
  metadata?: SourceFileMetadata | null;
  /**
   * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
   */
  depends_on?: {
    macros?: string[];
    nodes?: string[];
  };
  refs?: RefArgs[];
  created_at?: number;
  /**
   * SemanticModelConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True)
   */
  config?: {
    enabled?: boolean;
    [k: string]: unknown;
  };
  primary_entity?: string | null;
}
/**
 * NodeRelation(alias: str, schema_name: str, database: Union[str, NoneType] = None, relation_name: Union[str, NoneType] = None)
 */
export interface NodeRelation {
  alias: string;
  schema_name: string;
  database?: string | null;
  relation_name?: string | null;
}
/**
 * Defaults(agg_time_dimension: Union[str, NoneType] = None)
 */
export interface Defaults {
  agg_time_dimension?: string | null;
}
/**
 * Entity(name: str, type: dbt_semantic_interfaces.type_enums.entity_type.EntityType, description: Union[str, NoneType] = None, role: Union[str, NoneType] = None, expr: Union[str, NoneType] = None)
 */
export interface Entity {
  name: string;
  type: 'foreign' | 'natural' | 'primary' | 'unique';
  description?: string | null;
  role?: string | null;
  expr?: string | null;
}
/**
 * Measure(name: str, agg: dbt_semantic_interfaces.type_enums.aggregation_type.AggregationType, description: Union[str, NoneType] = None, create_metric: bool = False, expr: Union[str, NoneType] = None, agg_params: Union[dbt.contracts.graph.semantic_models.MeasureAggregationParameters, NoneType] = None, non_additive_dimension: Union[dbt.contracts.graph.semantic_models.NonAdditiveDimension, NoneType] = None, agg_time_dimension: Union[str, NoneType] = None)
 */
export interface Measure {
  name: string;
  agg:
    | 'sum'
    | 'min'
    | 'max'
    | 'count_distinct'
    | 'sum_boolean'
    | 'average'
    | 'percentile'
    | 'median'
    | 'count';
  description?: string | null;
  create_metric?: boolean;
  expr?: string | null;
  agg_params?: MeasureAggregationParameters | null;
  non_additive_dimension?: NonAdditiveDimension | null;
  agg_time_dimension?: string | null;
}
/**
 * MeasureAggregationParameters(percentile: Union[float, NoneType] = None, use_discrete_percentile: bool = False, use_approximate_percentile: bool = False)
 */
export interface MeasureAggregationParameters {
  percentile?: number | null;
  use_discrete_percentile?: boolean;
  use_approximate_percentile?: boolean;
}
/**
 * NonAdditiveDimension(name: str, window_choice: dbt_semantic_interfaces.type_enums.aggregation_type.AggregationType, window_groupings: List[str])
 */
export interface NonAdditiveDimension {
  name: string;
  window_choice:
    | 'sum'
    | 'min'
    | 'max'
    | 'count_distinct'
    | 'sum_boolean'
    | 'average'
    | 'percentile'
    | 'median'
    | 'count';
  window_groupings: string[];
}
/**
 * Dimension(name: str, type: dbt_semantic_interfaces.type_enums.dimension_type.DimensionType, description: Union[str, NoneType] = None, is_partition: bool = False, type_params: Union[dbt.contracts.graph.semantic_models.DimensionTypeParams, NoneType] = None, expr: Union[str, NoneType] = None, metadata: Union[dbt.contracts.graph.semantic_models.SourceFileMetadata, NoneType] = None)
 */
export interface Dimension {
  name: string;
  type: 'categorical' | 'time';
  description?: string | null;
  is_partition?: boolean;
  type_params?: DimensionTypeParams | null;
  expr?: string | null;
  metadata?: SourceFileMetadata | null;
}
/**
 * DimensionTypeParams(time_granularity: dbt_semantic_interfaces.type_enums.time_granularity.TimeGranularity, validity_params: Union[dbt.contracts.graph.semantic_models.DimensionValidityParams, NoneType] = None)
 */
export interface DimensionTypeParams {
  time_granularity: 'day' | 'week' | 'month' | 'quarter' | 'year';
  validity_params?: DimensionValidityParams | null;
}
/**
 * DimensionValidityParams(is_start: bool = False, is_end: bool = False)
 */
export interface DimensionValidityParams {
  is_start?: boolean;
  is_end?: boolean;
}
